<!doctype html>
<html>
	<head>
		<meta charset = 'utf-8'>
		<title>五子连珠</title>
		<style>
			body{
				margin:0;
				background-image:url(img/1.jpg);
			}
			table{
				border-collapse:collapse;
				font-family:'楷体';
				font-size:40px;
			}
			td{
				border:1px solid #333;
				border-collapse:collapse;
				padding:0;
				width:29px;
				height:29px;
			}
		</style>
	</head>

	<body>
		<div id="maintable">
		</div>
	</body>
	<script>

		var	SIZE = 15;
		var tdArray;
		var beginI;
		var beginJ;
		var endI;
		var endJ;
		var num;
		var ok;
		var click = 0;
		var noRoad = '无路可走';
		var BallArray = new Array(
			"url(img/blue.png)",
			"url(img/blue00.png)",
			"url(img/green.png)",
			"url(img/red.png)",
			"url(img/purple.png)",
			"url(img/yellow.png)"
		);
		var infArray = new Array(SIZE*SIZE);

		createTable();
		initBall();
		getBeginAndEnd();

		/*
			用javascript动态产生SIZE*SIZE的表格
		*/
		function createTable(){
			var oDiv = document.getElementById("maintable");
			oDiv.innerHTML = "<center><table><caption>五子连珠</caption></table></center>";
			var oTable = oDiv.getElementsByTagName("table")[0];
			var oTbody = document.createElement("tbody");
			tdArray = new Array();
			for(var i=0 ; i<SIZE ; i++){
				var oTr = document.createElement("tr");
				tdArray[i] = new Array();
				for(var j = 0 ; j<SIZE ; j++ ){
					var oTd = document.createElement("td");
					tdArray[i][j] = oTd;
					oTr.appendChild(oTd);
				}
				oTbody.appendChild(oTr);
			}
			oTable.appendChild(oTbody);
		}

		/*在随机的位置放上随机的小球
			用Math.random()函数产生随机数代表小球的编号小球编号是大于0小与6的整数
			创建一个数组用来存放小球的地址
			再用两次Math.random()函数获得小球的位置*/
		function initBall(){
			for(var i = 0 ; i < 4 ; i++){
				var ranBall = parseInt(Math.random()*6);
				if(ranBall >= 0 && ranBall < 6){
					do{
						var ranRow = parseInt(Math.random()*SIZE);
						var ranCell = parseInt(Math.random()*SIZE);
						if(tdArray[ranRow][ranCell].style.backgroundImage == ''){
							tdArray[ranRow][ranCell].style.backgroundImage = BallArray[ranBall];
							break;
						}
						else{
							ranCell++;
							if(ranCell >= SIZE){
								ranCell = 0;
								ranRow++;
								if(ranRow >= SIZE){
									ranRow = 0;
								}
							}

						}
					}while(1);
				}
			}
		}

		/*
			为每个td对象创建点击事件新建一个变量作为点击事件的判断条件
			然后通过点击事件确认起点和终点
			再寻找最短路径
			再讲最短路径存储在数组里
			实用定时器移动小球
		*/
		function getBeginAndEnd(){
			for(var i = 0 ; i < SIZE ; i++ ){
				for(var j = 0 ; j < SIZE ; j++ ){
					tdArray[i][j].onclick = clickthis;
				}
			}
		}

		/*
			鼠标点击时判断是否是第一次点击，找到点击的td的行和列并赋值给beginI，beginJ，endI，endJ
			如果是第二次点击并且该位置没有小球则寻找最短路径然后移动小球
		*/
		function clickthis(){
			for(var i = 0 ;i < SIZE; i++){
				for(var j = 0 ; j < SIZE ; j++){
					if(this == tdArray[i][j]){
						break;
					}
				}
				if(j < SIZE)
					break;
			}
			switch(click){
			case 0:
				if(tdArray[i][j].style.backgroundImage != ''){
					beginI = i;
					beginJ = j;
					click++;
				}
				break;
			case 1:
				if (tdArray[i][j].style.backgroundImage == ''){
					endI = i;
					endJ = j;
					searchMinPath();//寻找最短路径
				}
				else{
					beginI = i;
					beginJ = j;
				}
				break;
			}
		}

		/*
			寻找最短路径
				创建一个结构数组，有6个变量，第一个变量prelocation代表上一个上一步走过的为组织在次数组里的下标，第二个变量curI代表当前位置的行数，第三个变量curJ代表当前位置的列数，第四个变量g代表已走过的实际距离，第五个变量f代表估计与终点的距离，第六个变量flag代表该位置是否已经走过
				首先将起点beginI，beginJ存放到该数组里面，令prelocation等于-1，代表这是起点，flag置为1
				在这个数组里找g+f最小的一个将其变量flag值为2；
				将该位置周围的td对象放入数组里，在从里面找f+g最小的一个将flag置为2
				重复上面两步直到f+g最小的一个是终点；
		*/
		function infObject(prelocation,curI,curJ,g,f){
			this.prelocation = prelocation;
			this.curI = curI;
			this.curJ = curJ;
			this.g = g;
			this.f = f;
			this.flag = 1;
		}

		function getF(i,j){//计算f的值
			return Math.abs(i-endI)+Math.abs(j-endJ);
		}

		function Addbeginlocation(){//将开始位置添加到infArray数组里
			num=0;
			infArray[num] = new infObject(-1 , beginI , beginJ , 0 ,getF(beginI,beginJ));
			num++;
		}

		function AddtoinfArray(prelocation,curI,curJ,g,f){//声明新的infObject变量并将其添加到infArray里面
			var i = 0;
			//首先判断要添加的值有没有在infArray里面
			//如果有跳出循环判断infArray里的数据和要添加数据相比谁的g+f最小，
			//如果要添加的数据的g+f更小，则把infArray里的数据的prelocation替换成要添加的prelocation
			//否则不做处理
			//如果没有将新数据添加到infArray数组里面
			for( ; i < num ; i++){
				if(curI == infArray[i].curI && curJ == infArray[i].curJ)
					break;
			}

			if(!(i < num)){
				infArray[num] = new infObject(prelocation,curI,curJ,g,f);
				num++;
			}
			else{
				if(infArray[i].g+infArray[i].f > g+f){
					infArray[i].prelocation = prelocation ;
				}
			}
		}

		function getMinGF(){//在没有走过的路径中找g+f最小的一个
			var i = 0;
			var min;
			for (; i < num ; i++){
				if( infArray[i].flag == 1  ){
					break;
				}
			}
			if(!(i < nim))
				return -1;
			min = infArray[i].g+infArray[i].f;
			var pos = i;
			for( ; i < num ; i++){
				if (infArray[i].g+infArray[i].f < min){
					min = infArray[i].g+infArray[i].f ;
					pos = i;
				}
			}
			return pos;
		}
		function searchMinPath(){//寻找最短路径
			Addbeginlocation();//给infArray添加起点位置信息
			ok = 0;

			while( ok == 0){
				var pos = getMinGF();//在infArray之中寻找flag为1并且g+f最小的一个

				if(pos = -1)
					alert(noRoad);
				else{
					var curI = infArray[pos].curI;
					var curJ = infArray[pos].curJ;
					var g = infArray[pos].g;

					if(ok == 0 && curI>0){//将当前位置上面的td对象添加到infArray里面
						AddtoinfArray( pos,curI-1,curJ, g, getF(curI-1 , curJ) );
					}
					if(ok == 0 && curJ<SIZE-1 ){//将当前位置右方的td对象添加到infArray里面
						AddtoinfArray( pos,curI,curJ+1, g, getF(curI , curJ+1) );
					}
					if(ok == 0 && curI<SIZE-1){//将当前位置下面的td对象添加到infArray里面
						AddtoinfArray( pos,curI+1,curJ, g, getF(curI+1 , curJ) );
					}
					if(ok == 1 && curJ>0 ){//将当前位置左方的td对象添加到infArray里面
						AddtoinfArray( pos,curI,curJ+1, g, getF(curI , curJ-1) );
					}
				}
			}
		}
	</script>
</html>